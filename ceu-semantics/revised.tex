\documentclass[11pt,a4paper,oneside,leqno]{article}
%- Packages -%
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[protrusion=true,expansion]{microtype}
\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue}%
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[varg]{txfonts}
\usepackage{mathtools}
\usepackage[nameinlink]{cleveref}
%-
\newcommand{\MARK}[1]{\textcolor{red}{#1}}
\newcommand{\TODO}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\FIXME}[1]{\textcolor{red}{[FIXME: #1]}}
\usepackage[textwidth=3.7cm,textsize=scriptsize,shadow]{todonotes}
\setlength{\marginparwidth}{3.7cm}
%-
\usepackage{enumitem}
\setlist{noitemsep}
\setlist[enumerate]{label=(\roman*)}
\newlist{case}{enumerate}{2}
\setlist[case]{itemsep=\topsep}
\setlist[case,1]{label=[Case~\arabic{casei}],ref=\arabic{casei},
  leftmargin=0pt,itemindent=*}
\setlist[case,2]{label=[Case~\arabic{casei}.\arabic{caseii}],
  ref=\arabic{casei}.\arabic{caseii},
  leftmargin=\parindent,itemindent=*,labelindent=\parindent}
\crefname{casei}{case}{cases}
\Crefname{casei}{Case}{Cases}
\crefname{caseii}{case}{cases}
\Crefname{caseii}{Case}{Cases}
%-
\usepackage{bussproofs}
\def\labelSpacing{0em}
\def\ScoreOverhang{0em}
\def\defaultHypSeparation{\quad}
\EnableBpAbbreviations
%- Theorems -%
\numberwithin{equation}{section}
\usepackage{thmtools}
\declaretheorem[
  name=Theorem,
  refname={theorem,theorems},
  Refname={Theorem,Theorems},
  numberwithin=section,
  style=plain,
  ]{theorem}
\declaretheorem[
  name=Lemma,
  refname={lemma,lemmas},
  Refname={Lemma,Lemmas},
  sharenumber=theorem,
  style=plain,
  ]{lemma}
\declaretheorem[
  name=Proposition,
  refname={proposition,propositions},
  refname={Proposition,Propositions},
  sharenumber=theorem,
  style=plain,
  ]{proposition}
\declaretheorem[
  name=Fallacy,
  refname={fallacy,fallacies},
  Refname={Fallacy,Fallacies},
  numbered=no,
  style=plain,
  ]{fallacy}
\declaretheorem[
  name=Convention,
  refname={convention,conventions},
  Refname={Convention,Conventions},
  numbered=no,
  style=definition,
  ]{convention}
\declaretheorem[
  name=Definition,
  refname={definition,definitions},
  Refname={Definition,Definitions},
  sharenumber=theorem,
  style=definition,
  ]{definition}
\declaretheorem[
  name=Notation,
  refname={notation,notations},
  Refname={Notation,Notations},
  numbered=no,
  style=remark,
  ]{notation}
\declaretheorem[
  name=Example,
  refname={example,examples},
  Refname={Example,Exemples},
  numbered=no,
  style=remark,
  ]{example}
%- Symbols -%
\def\Ceu{C\'eu}
\let\nil=\varepsilon
\def\<#1>{\langle#1\rangle}
\def\|#1|{\left|#1\right|}
\def\blocked{\mathit{blocked}}
\def\clear{\mathit{clear}}
\def\eval{\mathit{eval}}
\def\pop{\mathit{pop}}
\makeatletter
\def\@raise#1#2#3{
  \setbox0=\hbox{#1}%
  \mathbin{%
    \hbox to\wd0{%
      \rlap{\box0}\hfill\raise#2\hbox{$\scriptstyle{#3}$}\hfill
    }%
  }%
}
\def\step#1{\@raise{$\to$}{1.1ex}{#1}}
\def\stepx#1{\@raise{$\step{#1}$}{-.75ex}{\ast}}
\def\ostep#1{\@raise{$\Rightarrow$}{1.1ex}{#1}}
\def\ostepx#1{\@raise{$\ostep{#1}$}{-.75ex}{\ast}}
\def\react#1{\@raise{$\vDash$}{1.3ex}{#1}}
\makeatother
%-
\makeatletter
\def\@ceuop#1{\mathop{\texttt{#1}}}%
\def\@ceubin#1{\mathbin{\texttt{#1}}}%
\def\ceu{\protect\@ceu}
\def\@ceu#1{%
  \bgroup
  \def\Skip{\@ceuop{skip}}%
  \def\Mem{\@ceuop{mem}}%
  \def\Attr##1##2{##1\coloneqq##2}%
  \def\AwaitExt{\@ceuop{awaitext}}%
  \def\Await{\@ceuop{await}}%
  \def\Emit{\@ceuop{emit}}%
  \def\Break{\@ceuop{break}}%
  \def\Ifelse##1##2##3{\@ceuop{if}##1\@ceuop{then}{##2}\@ceuop{else}{##3}}%
  \def\Loop{\@ceuop{loop}}%
  \def\And{\@ceubin{and}}%
  \def\Or{\@ceubin{or}}%
  \def\Fin{\@ceuop{fin}}%
  \def\AwaitingExt{\@ceuop{@awaitingext}}%
  \def\Awaiting{\@ceuop{@awaiting}}%
  \def\Emitting{\@ceuop{@emitting}}%
  \def\Atloop{\@ceuop{@loop}}%
  \def\Final{\@ceuop{halt}}%
  \def\True{\@ceuop{$\top$}}%
  \def\False{\@ceuop{$\bot$}}%
  \ensuremath{#1}\ignorespaces
  \egroup
}
\makeatother

\title{Determinism and termination in the semantics
  of the Céu programming language}
\begin{document}
\maketitle


\section{The original formulation}
\label{sec:orig}

The semantics discussed in this section follows as much as possible the
original semantics of \Ceu\ presented in~\cite{?}.  Any deviations from
original definitions are duly noted in the text.


\subsection{Abstract syntax}
\label{sub:orig:syntax}

The \emph{abstract syntax} of \Ceu\ programs is given by the following
grammar:
%%
\todo{%
  (1)~$\ceu{\protect\Skip}$ precisa aparecer na gramática já que
  aprece nos programas em~$P$.\newline
  %%
  (2)~Atribuição agora aparece explicitamente na gramática.  Expressões
  aritméticas e booleanas também estão na gramática mas a sua estrutura
  interna é omitida.}
%%
\bgroup
\vskip\abovedisplayskip
\noindent
\hfil\hbox{%
  \vtop{%
    \tabskip0pt
    \offinterlineskip
    \halign{\strut\hfil$#$&$\;#$\hfil&\qquad#\hfil\cr
      p\in{P}\Coloneqq
          & \MARK{\ceu{\Skip}}          & do nothing\cr
      \mid& \MARK{\ceu{\Attr{v}{a}}}    & assignment\cr
      \mid& \ceu{\Await(e)}             & await event\cr
      \mid& \ceu{\Emit(e)}              & emit event\cr
      \mid& \ceu{\Break}                & break innermost loop\cr
      \mid& \ceu{\Ifelse{b}{p_1}{p_2}}  & conditional\cr
      \mid& \ceu{p_1;p_2}               & sequence\cr
      \mid& \ceu{\Loop p_1}             & repetition\cr
      \mid& \ceu{p_1\And p_2}           & par/and\cr
      \mid& \ceu{p_1\Or p_2}            & par/or\cr
      \mid& \ceu{\Fin p_1}              & finalization\cr
      \mid& \ceu{\Awaiting(e,n)}        & awaiting~$e$ since reaction~$n$\cr
      \mid& \ceu{\Emitting(e,n)}        & emitting~$e$ on stack level~$n$\cr
      \mid& \ceu{p_1\Atloop p_2}        & unwinded loop\cr
    }%
  }%
}\hfil%
\vskip\belowdisplayskip
\egroup
%%
\noindent
where~$n\in{N}$ is an integer, $v\in{V}$~is a memory location (variable)
identifier, $e\in{E}$~is an event identifier, $a\in{A}$~is an arithmetic
expression, $b\in{B}$ is a boolean expression, and~$p$, $p_1$, $p_2\in{P}$
are programs.  We assume the usual structure for arithmetic and boolean
expressions, and omit their definition.


\subsection{The reaction inner-step relation}
\label{sub:orig:inner}

The \emph{state} of a \Ceu\ program within a reaction is represented by a
stack of events~$\alpha=e_1e_2\dots{e_n}\in{E}^*$ together with a memory
map~$m\colon{v}\to{N}\in\mathcal{M}$.  A \emph{configuration} is a
4-tuple~$\<p,\alpha,m,n>\in\Delta$ that represents the situation of
program~$p$ waiting to be evaluated in state~$\<\alpha,m>$ and reaction~$n$.
Given an initial configuration, each small-step within a program reaction is
determined by the reaction-inner-step
relation~$\mathord{\step{}}\in\Delta\times\Delta$ such
that~$\<p,\alpha,m,n>\step{}\<p',\alpha',m',n>$ iff a reaction inner-step of
program~$p$ in state~$\<\alpha,m>$ and reaction number~$n$ evaluates to a
modified program~$p'$ and a modified state~$\<\alpha',m'>$ in the same
reaction~($n$).  Since relation~$\step{}$ can only relate configurations
with the same~$n$, we shall write $\<p,\alpha,m>\step{n}\<p',\alpha',m'>$
for~$\<p,\alpha,m,n>\step{}\<p',\alpha',m',n>$.

Relation~$\step{}$ is defined inductively with the help of the auxiliary
functions~$\eval$, $\blocked$, and~$\clear$.  The~$\eval$ function evaluates
arithmetic or boolean expressions on a given memory; we omit its definition
and assume that such evaluation is deterministic and always terminates.
The~$\blocked$ function is a predicate that determines if all trails of a
program~$p$ are blocked on a given event stack and reaction number.  And
the~$\clear$ function extracts the body of~$\ceu{\Fin}$ blocks from a given
program.

\begin{definition}[label={def:orig:blocked}]
  Function~$\blocked\colon{P\times{E^*}\times{N}}\to\{0,1\}$ is defined
  inductively as follows.
  %%
  \todo{Intuitivamente, um programa~$p$ está bloqueado se toda trilha de~$p$
    está~(i) aguardando ($\ceu{\protect\Awaiting}$) algum evento que não
    está no topo da pilha ou que foi emitido na reação atual, ou~(ii) acabou
    de emitir um evento ($\ceu{\protect\Emitting}$) e esse evento ainda não
    foi consumido (i.e., está na pilha).  É isso?}
  %%
  \begin{align*}
    \blocked(\ceu{\Skip},e\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Attr{v}{a}},e\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Await(e')},e\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Emit(e')},e\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Break},e\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Ifelse{b}{p_1}{p_2}},e\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{p_1;p_2},e\alpha,n)
    &=\blocked(p_1,e\alpha,n)\\
    %%
    \blocked(\ceu{\Loop p},e\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{p_1\And p_2},e\alpha,n)
    &=\blocked(p_1,e\alpha,n)\cdot\blocked(p_2,e\alpha,n)\\
    %%
    \blocked(\ceu{p_1\Or p_2},e\alpha,n)
    &=\blocked(p_1,e\alpha,n)\cdot\blocked(p_2,e\alpha,n)\\
    %%
    \blocked(\ceu{\Fin p_1},e\alpha,n)
    &=0\\
    % %%
    \blocked(\ceu{\Awaiting(e',n')},e\alpha,n)
    &=
      \begin{cases}
        1 &\text{if~$e\ne{e'}$ or~$n=n'$}\\
        0 &\text{otherwise}
      \end{cases}\\
    %%
    \blocked(\ceu{\Emitting(n')},e\alpha,n)
    &=
      \begin{cases}
        1 &\text{if~}\|e\alpha|\ne{n'}\\
        0 &\text{otherwise}
      \end{cases}\\
    %%
    \blocked(\ceu{p_1\Atloop p_2},e\alpha,n)
    &=\blocked(p_1,e\alpha,n)
  \end{align*}
\end{definition}

\begin{definition}[label={def:orig:clear}]
  Function $\clear\colon{P}\to{P'}$ is defined inductively as follows.
  %%
  \todo{Intuitivamente, dado um programa~$p$, a função~$\clear$ concatena em
    sequência o corpo das \emph{primeiras} ocorrências
    de~$\ceu{\protect\Fin}$ em cada trilha de~$p$, e retorna a sequência
    resultante.  A sintaxe do corpo de instruções~$\ceu{\protect\Fin}$ está
    restrita a programas em~$P'\subseteq{P}$, viz., que não contém
    instruções~$\ceu{\protect\Await}$, $\ceu{\protect\Awaiting}$,
    $\ceu{\protect\Emit}$, $\ceu{\protect\Emitting}$, $\ceu{\protect\And}$,
    $\ceu{\protect\Or}$ e~$\ceu{\protect\Fin}$.  É isso?
    %%
    Se sim, por que a chamada recursiva para~\emph{loops} mas não
    para~\emph{if-else}?}
  %%
\begin{align*}
    \clear(\ceu\Skip)
    &=\ceu\Skip\\
    %%
    \clear(\ceu{\Attr{v}{a}})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Await(e')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Emit(e')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Break})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Ifelse{b}{p_1}{p_2}})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{p_1;p_2})
    &=\clear(p_1)\\
    %%
    \clear(\ceu{\Loop p})
    &=\clear(p)\\
    %%
    \clear(\ceu{p_1\And p_2})
    &=\clear(p_1);\clear(p_2)\\
    %%
    \clear(\ceu{p_1\Or p_2})
    &=\clear(p_1);\clear(p_2)\\
    %%
    \clear(\ceu{\Fin p})
    &=p\\
    % %%
    \clear(\ceu{\Awaiting(e',n')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Emitting(n')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{p_1\Atloop p_2})
    &=\clear(p_1)
  \end{align*}
\end{definition}

\todo[inline]{Ainda na definição da~$\clear$, será que não é preciso chamar
  a função recursivamente também para a segunda metade da sequência?  Do
  jeito que está
  \[
    \clear(\ceu{(\protect\Attr{v}{a};\protect\Fin{p})
      \protect\And\protect\Skip})
    =\ceu{\protect\Skip;\protect\Skip}.
  \]
  Não deveria ser
  \[
    \clear(\ceu{(\protect\Attr{v}{a};\protect\Fin{p})
      \protect\And\protect\Skip})
    =\ceu{p;\protect\Skip}?
  \]
}

\input{revised-rules}

The next theorem establishes that the reaction inner-step relation is
deterministic, i.e., that it is in fact a \emph{partial} function.

\begin{theorem}[label={thm:orig:det-inner},
name={Determinism of the inner-step relation}]
For all~$p$, $p_1$, $p_2\in{P}$, $\alpha$, $\alpha_1$, $\alpha_2\in{E^*}$,
$m$, $m_1$, $m_2\in\mathcal{M}$, and~$n\in{N}$,
\begin{gather*}
  \text{if}\quad\<p,\alpha,m>\step{n}\<p_1,\alpha_1,m_1>
  \quad\text{and}\quad
  \<p,\alpha,m>\step{n}\<p_2,\alpha_2,m_2>,\\
  \text{then}\quad\<p_1,\alpha_1,m_1>=\<p_2,\alpha_2,m_2>.
\end{gather*}
\end{theorem}
\input{revised-inner-det-proof}

The next lemma establishes that given a nontrivial program~$p$ either it is
possible to advance~$p$ by an inner-step or all its trails are blocked, but
not both.
%%
\FIXME{Faltou incluir~$\ceu{\protect\Fin{p}}$ na lista dos programas
  triviais, i.e., que não avançam.}

\begin{lemma}[label={lem:orig:inner-step-or-blocked}]
  For all~$p\in{P}$, $\alpha\in{E^*}$, $m\in\mathcal{M}$, and~$n\in{N}$,
  if~$p\ne\ceu{\Skip},\ceu{\Attr{v}{a}},\ceu{\Break}$ then either
  \[
    \exists{\delta\in\Delta}(\<p,\alpha,m>\step{n}\delta)
    \quad\text{or}\quad \blocked(p,\alpha,n)=1,
  \]
  but not both.
\end{lemma}
\input{revised-lemma-proof}


\subsection{The reaction outer-step relation}
\label{sub:orig:outer}

From the previous inner-step relation we define the outer-step
relation~($\ostep{}$) which when necessary pops the event stack and advances
blocked programs.  The auxiliary function~$\pop$ is used to pop the event
stack.

\begin{definition}[label={def:orig:pop}]
  Function~$\pop\colon{E^*}\to{E^*}$ is defined as follows.
  \begin{align*}
    \pop(\nil)&=\nil\\
    \pop(e\alpha)&=\alpha
  \end{align*}
\end{definition}

\begin{definition}[label={def:orig:outer-step},name={Reaction outer-step}]
  \begin{alignat}{2}
    \label{def:orig:outer:advance}
    &\hskip-3.45em
    \AXC{$\<p,\alpha,m>\step{n}\<p',\alpha',m'>$}
    \UIC{$\<p,\alpha,m>\ostep{n}\<p',\alpha',m'>$}
    \DP
    &&\quad\text{if~$\blocked(p,\alpha,n)=0$}
    \\[1\jot]
    %%
    \label{def:orig:outer:pop}
    \<p,e\alpha,m>
    &\ostep{n}\<p,\alpha',m>
    &&\quad\parbox{10em}{if~$\blocked(p,\alpha,n)=1$,\\
        \strut\enspace with~$\alpha'=\pop(\alpha)$}
  \end{alignat}
\end{definition}

The next two theorem establish that the outer-steps are deterministic and
always terminate for nontrivial programs, i.e., that it is in fact the
reaction outer-step relation is in fact a \emph{total} function (for
nontrivial programs).

\begin{theorem}[label={thm:orig:det-outer},
  name={Determinism of the outer-step relation}]
  For all~$p$, $p_1$, $p_2\in{P}$, $\alpha$, $\alpha_1$, $\alpha_2\in{E^*}$,
  $m$, $m_1$, $m_2\in\mathcal{M}$, and~$n\in{N}$,
  \begin{gather*}
    \text{if}\quad\<p,\alpha,m>\ostep{n}\<p_1,\alpha_1,m_1>
    \quad\text{and}\quad
    \<p,\alpha,m>\ostep{n}\<p_2,\alpha_2,m_2>,\\
    \text{then}\quad\<p_1,\alpha_1,m_1>=\<p_2,\alpha_2,m_2>.
  \end{gather*}
\end{theorem}
\input{revised-outer-det-proof2}

\begin{theorem}[label={thm:orig:term-outer},
  name={Termination of the outer-step relation}]
  For all~$p\in{P}$, $\alpha\in{E}$, and~$m\in\mathcal{M}$,
  if~$p\ne\ceu{\Skip},\ceu{\Attr{v}{a}},\ceu{\Break}$ then
  \[
    \exists{\delta\in\Delta}(\<p,\alpha,m>\ostep{n}\delta).
  \]
\end{theorem}
\input{revised-outer-term-proof2}


\subsection{The reaction relation}
\label{sub:orig:reaction}

From the reflexive-transitive closure of the outer-step
relation~($\ostep{\ast}$) we define the reaction
relation~$\react{}\subseteq\Delta\times(P\times\mathcal{M}\times{N})$, which
computes a full program reaction.  Given an initial configuration, the
reaction relation evaluates it until the event stack becomes empty.

\begin{definition}[label={def:orig:reaction},name={Reaction}]
  Let~$p$, $p'\in{P}$, $\alpha\in{E^*}$, $m$, $m'\in\mathcal{M}$.  Then
  \[
    \<p,\alpha,m>\react{n}\<p',m'>
    \quad\text{iff}\quad
    \<p,\alpha,m,n>\ostep\ast\<p',\nil,m',n>.
  \]
\end{definition}

The next two theorems establish, respectively, that reactions are
deterministic and always terminate (for nontrivial programs).  The proofs of
these theorems depend on the assumption that every execution path within the
body of a loop instruction ($\ceu{\Loop{p}}$) contains an occurrence
of~$\ceu{\Break}$ or~$\ceu{\Await(e)}$.  This assumption is checked
statically by the \Ceu\ compiler.
%%
\todo{Na nova semântica basta dizer que~$e$ é um evento externo.}

\TODO{Antes do determinismo e terminação precisa de um lema para grantir a
  correção da definição anterior, i.e., que um número finito de passos
  eventualmente leva a uma configuração com pilha vazia.  Nessa prova vai
  ser preciso usar a hipótese do loop.  A prova deve sair por indução no
  número de passos.}

\begin{theorem}[label={thm:orig:det-react},
  name={Determinism of the reaction relation}]
  For all~$p$, $p_1$, $p_2\in{P}$, $\alpha\in{E^*}$, $m$, $m_1$, $m_2\in\mathcal{M}$, and~$n\in{N}$,
  \begin{gather*}
    \text{if}\quad\<p,\alpha,m>\react{n}\<p_1,m_1>
    \quad\text{and}\quad
    \<p,\alpha,m>\react{n}\<p_2,m_2>,\\
    \text{then}\quad\<p_1,m_1>=\<p_2,m_2>.
  \end{gather*}
\end{theorem}
\begin{proof}
  \TODO{?}
\end{proof}

\begin{theorem}[label={thm:orig:term-react},
  name={Termination of the reaction relation}]
  For all~$p\in{P}$, $\alpha\in{E}$, and~$m\in\mathcal{M}$,
  if~$p\ne\ceu{\Skip},\ceu{\Attr{v}{a}},\ceu{\Break}$ then
  \[
    \<p,\alpha,m>\react{n}\<p',m'>,
  \]
  for some~$p'\in{P}$ and~$m'\in\mathcal{M}$.
\end{theorem}
\begin{proof}
  \TODO{?}
\end{proof}


\section{Big-step version of the original formulation}
\label{sec:big}

\TODO{Minha ideia aqui é fazer uma versão big-step da formulação original.
  E no final comparar as duas versões, i.e., mostrar que são equivalentes.}

\begin{definition}
  \TODO{Parcial e provavelmente incorreta.}

  \noindent\emph{Empty program}
  \begin{equation}
    \<\nil,\alpha,m,n>\leadsto\<\alpha,m,n>
  \end{equation}

  \noindent\emph{Assignment}
  \begin{equation}
    \<\ceu{\Attr{v}{a}},\alpha,m,n>\leadsto\<\alpha,m[v/\eval(a)],n>
  \end{equation}

  \noindent\emph{Conditionals}
  \begin{alignat}{2}
    &\AXC{$\<p_1,\alpha,m,n>\leadsto\<\alpha',m',n'>$}
    \UIC{$\<\ceu{\Ifelse{b}{p_1}{p_2}},\alpha,m,n>
      \leadsto\<\alpha',m',n'>$}
    \DP
    &&\quad\text{if~$\eval(b,m)=1$}\\
    %%
    &\AXC{$\<p_2,\alpha,m,n>\leadsto\<\alpha',m',n'>$}
    \UIC{$\<\ceu{\Ifelse{b}{p_1}{p_2}},\alpha,m,n>
      \leadsto\<\alpha',m',n'>$}
    \DP
    &&\quad\text{if~$\eval(b,m)=0$}
  \end{alignat}

  \noindent\emph{Await}
  \begin{alignat}{2}
    &\AXC{$\<\ceu{\Awaiting(e,n+1)},e\alpha,m,n>\leadsto\<\alpha',m',n'>$}
    \UIC{$\<\ceu{\Await(e)},\alpha,m,n>\leadsto\<\alpha',m',n'>$}
    \DP
    &&\\[1\jot]
    %%
    &\<\ceu{\Awaiting(e',n')},e\alpha,m,n>\leadsto\<\alpha,m,n>
    &&\quad\text{if~$e'=e$ and~$n'<n$}\\[1\jot]
    %%
    &\AXC{$\<\ceu{\Awaiting(e',n')},\alpha,m,n>\leadsto\<\alpha'',m'',n''>$}
    \UIC{$\<\ceu{\Awaiting(e',n')},e\alpha,m,n>\leadsto\<\alpha'',m'',n''>$}
    \DP
    &&\quad\text{if~$e'\ne{e}$ or~$n'\ge{n}$}
  \end{alignat}

  \noindent\emph{Emit}
  \begin{alignat}{2}
    &\AXC{$\<\ceu{\Emitting(\|\alpha|)},e\alpha,m,n>
      \leadsto\<\alpha',m',n'>$}
    \UIC{$\<\ceu{\Emit(e)},\alpha,m,n>\leadsto\<\alpha',m',n'>$}
    \DP
    &&\\[1\jot]
    %%
    &\<\ceu{\Emitting(n')},e\alpha,m,n>\leadsto\<\alpha,m,n>
    &&\quad\text{if~$\|e\alpha|={n'}$}\\[1\jot]
    %%
    &\AXC{$\<\ceu{\Emitting(n')},\alpha,m,n>\leadsto\<\alpha'',m'',n''>$}
    \UIC{$\<\ceu{\Emitting(n')},e\alpha,m,n>\leadsto\<\alpha'',m'',n''>$}
    \DP
    &&\quad\text{if~$\|e\alpha|\ne{n'}$}
  \end{alignat}
\end{definition}

\end{document}
