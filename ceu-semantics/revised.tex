\documentclass[11pt,a4paper,oneside,leqno]{article}
%- Packages -%
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[protrusion=true,expansion]{microtype}
\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue}%
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[varg]{txfonts}
\usepackage{mathtools}
\usepackage[nameinlink]{cleveref}
%-
\newcommand{\MARK}[1]{\textcolor{red}{#1}}
\newcommand{\TODO}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\FIXME}[1]{\textcolor{red}{[FIXME: #1]}}
\usepackage[textwidth=3.7cm,textsize=scriptsize,shadow]{todonotes}
\setlength{\marginparwidth}{3.7cm}
%-
\usepackage{enumitem}
\setlist{noitemsep}
\setlist[enumerate]{label=(\roman*)}
\newlist{case}{enumerate}{2}
\setlist[case]{itemsep=\topsep}
\setlist[case,1]{label=[Case~\arabic{casei}],ref=\arabic{casei},
  leftmargin=0pt,itemindent=*}
\setlist[case,2]{label=[Case~\arabic{casei}.\arabic{caseii}],
  ref=\arabic{casei}.\arabic{caseii},
  leftmargin=\parindent,itemindent=*,labelindent=\parindent}
\crefname{casei}{case}{cases}
\Crefname{casei}{Case}{Cases}
\crefname{caseii}{case}{cases}
\Crefname{caseii}{Case}{Cases}
%-
\usepackage{bussproofs}
\def\labelSpacing{0em}
\def\ScoreOverhang{0em}
\def\defaultHypSeparation{\quad}
\EnableBpAbbreviations
%- Theorems -%
\numberwithin{equation}{section}
\usepackage{thmtools}
\declaretheorem[
  name=Theorem,
  refname={theorem,theorems},
  Refname={Theorem,Theorems},
  numberwithin=section,
  style=plain,
  ]{theorem}
\declaretheorem[
  name=Lemma,
  refname={lemma,lemmas},
  Refname={Lemma,Lemmas},
  sharenumber=theorem,
  style=plain,
  ]{lemma}
\declaretheorem[
  name=Proposition,
  refname={proposition,propositions},
  refname={Proposition,Propositions},
  sharenumber=theorem,
  style=plain,
  ]{proposition}
\declaretheorem[
  name=Fallacy,
  refname={fallacy,fallacies},
  Refname={Fallacy,Fallacies},
  numbered=no,
  style=plain,
  ]{fallacy}
\declaretheorem[
  name=Convention,
  refname={convention,conventions},
  Refname={Convention,Conventions},
  numbered=no,
  style=definition,
  ]{convention}
\declaretheorem[
  name=Definition,
  refname={definition,definitions},
  Refname={Definition,Definitions},
  sharenumber=theorem,
  style=definition,
  ]{definition}
\declaretheorem[
  name=Notation,
  refname={notation,notations},
  Refname={Notation,Notations},
  numbered=no,
  style=remark,
  ]{notation}
\declaretheorem[
  name=Example,
  refname={example,examples},
  Refname={Example,Exemples},
  numbered=no,
  style=remark,
  ]{example}
%- Symbols -%
\def\Ceu{C\'eu}
\let\nil=\varepsilon
\def\<#1>{\langle#1\rangle}
\def\|#1|{\left|#1\right|}
\def\blocked{\mathit{blocked}}
\def\halted{\mathit{halted}}
\def\clear{\mathit{clear}}
\def\eval{\mathit{eval}}
\def\pop{\mathit{pop}}
\makeatletter
\def\@raise#1#2#3{
  \setbox0=\hbox{#1}%
  \mathbin{%
    \hbox to\wd0{%
      \rlap{\box0}\hfill\raise#2\hbox{$\scriptstyle{#3}$}\hfill
    }%
  }%
}
\def\step#1{\@raise{$\to$}{1.1ex}{#1}}
\def\stepx#1{\@raise{$\step{#1}$}{-.75ex}{\ast}}
\def\ostep#1{\@raise{$\Rightarrow$}{1.1ex}{#1}}
\def\ostepx#1{\@raise{$\ostep{#1}$}{-.75ex}{\ast}}
\def\react#1{\@raise{$\vDash$}{1.3ex}{#1}}
\makeatother
%-
\makeatletter
\def\@ceuop#1{\mathop{\texttt{#1}}}%
\def\@ceubin#1{\mathbin{\texttt{#1}}}%
\def\ceu{\protect\@ceu}
\def\@ceu#1{%
  \bgroup
  \def\Skip{\@ceuop{skip}}%
  \def\Mem{\@ceuop{mem}}%
  \def\Attr##1##2{##1\coloneqq##2}%
  \def\AwaitExt{\@ceuop{awaitext}}%
  \def\Await{\@ceuop{await}}%
  \def\Emit{\@ceuop{emit}}%
  \def\Break{\@ceuop{break}}%
  \def\Ifelse##1##2##3{\@ceuop{if}##1\@ceuop{then}{##2}\@ceuop{else}{##3}}%
  \def\Loop{\@ceuop{loop}}%
  \def\And{\@ceubin{and}}%
  \def\Or{\@ceubin{or}}%
  \def\Fin{\@ceuop{fin}}%
  \def\AwaitingExt{\@ceuop{@awaitingext}}%
  \def\Awaiting{\@ceuop{@awaiting}}%
  \def\Emitting{\@ceuop{@emitting}}%
  \def\Atloop{\@ceuop{@loop}}%
  \def\Term{\@ceuop{$\epsilon$}}%
  \def\Final{\@ceuop{halt}}%
  \def\True{\@ceuop{$\top$}}%
  \def\False{\@ceuop{$\bot$}}%
  \ensuremath{#1}\ignorespaces
  \egroup
}
\makeatother

\title{A deterministic and terminating semantics for the synchronous
  language~\Ceu}
\begin{document}
\maketitle


\section{Introduction}
\label{sec:intro}

\Ceu~\cite{?} is a synchronous, imperative language for the programming of
reactive systems.  A \Ceu~program consists of multiple execution
\emph{trails} which synchronize by exchanging events.  There are two types
of events: \emph{internal events}, which are generated and consumed by
program trails, and \emph{external events}, which are generated by the
environment and consumed by program trails---trails cannot generate external
events.  A trail emits an internal event~$e$ by executing an
instruction~$\ceu{\Emit(e)}$\dots
%%
\todo{Give quick, informal introduction to \Ceu.  Be as direct as possible.}

In this report, we present a formal semantics for~\Ceu\ program reactions,
and prove their determinism and termination.  The semantics follows the
structural operational approach to semantics in which the meaning of
programs is defined in terms of their execution steps in an abstract
machine~\cite{?}.
%%
\todo{Describe the goals of the report, main results, and overall
  structure.}


\section{Formal semantics}
\label{sec:sem}


\subsection{Abstract syntax}
\label{sub:sem:syntax}

The \emph{abstract syntax} of \Ceu\ programs is given by the following
grammar:
\bgroup
\vskip\abovedisplayskip
\noindent
\hfil\hbox{%
  \vtop{%
    \tabskip0pt
    \offinterlineskip
    \halign{\strut\hfil$#$&$\;#$\hfil&\qquad#\hfil\cr
      p\in{P}\Coloneqq
          & \ceu{\Skip}                 & do nothing\cr
      \mid& \ceu{\Attr{v}{a}}           & set variable~$v$ to~$a$\cr
      \mid& \ceu{\Break}                & break loop or trail\cr
      \mid& \ceu{\Await(e)}             & await event~$e$\cr
      \mid& \ceu{\Emit(e)}              & emit event~$e$\cr
      \mid& \ceu{\Ifelse{b}{p_1}{p_2}}  & conditional\cr
      \mid& \ceu{p_1;p_2}               & sequence\cr
      \mid& \ceu{\Loop p_1}             & repetition\cr
      \mid& \ceu{p_1\And p_2}           & par/and\cr
      \mid& \ceu{p_1\Or p_2}            & par/or\cr
      \mid& \ceu{\Fin p^\star}              & finalization\cr
      \mid& \ceu{\Awaiting(e,n)}        & awaiting~$e$ since reaction~$n$\cr
      \mid& \ceu{\Emitting(e,n)}        & emitting~$e$ on stack level~$n$\cr
      \mid& \ceu{p_1\Atloop p_2}        & unwinded loop\cr
    }%
  }%
}\hfil%
\vskip\belowdisplayskip
\egroup
%%
\noindent
where~$n\in{N}$ is an integer, $v\in{V}$~is a memory location (variable)
identifier, $e\in{E}$~is an event identifier, $a\in{A}$~is an arithmetic
expression, $b\in{B}$ is a boolean expression, and~$p$, $p_1$, $p_2\in{P}$
are programs.  We assume the usual structure for arithmetic and boolean
expressions, and omit their definition.  We also assume that the body
of~$\ceu{\Fin}$ blocks, $p^\star$, contains only instructions of the
form~$\ceu{\Skip}$, $\ceu{\Attr{v}{a}}$,
$\ceu{\Ifelse{b}{p_1^\star}{p_2^\star}}$ and~$\ceu{p_1^\star;p_2^\star}$.


\subsection{The reaction inner-step relation}
\label{sub:sem:inner}

The \emph{state} of a \Ceu\ program within a reaction is represented by a
stack of events~$\alpha=e_1e_2\dots{e_n}\in{E}^*$ together with a memory
map~$m\colon{v}\to{N}\in\mathcal{M}$.  A \emph{configuration} is a
4-tuple~$\<p,\alpha,m,n>\in\Delta$ that represents the situation of
program~$p$ waiting to be evaluated in state~$\<\alpha,m>$ and reaction~$n$.
Given an initial configuration, each small-step within a program reaction is
determined by the reaction-inner-step
relation~$\mathord{\step{}}\in\Delta\times\Delta$ such
that~$\<p,\alpha,m,n>\step{}\<p',\alpha',m',n>$ iff a reaction inner-step of
program~$p$ in state~$\<\alpha,m>$ and reaction number~$n$ evaluates to a
modified program~$p'$ and a modified state~$\<\alpha',m'>$ in the same
reaction~($n$).  Since relation~$\step{}$ can only relate configurations
with the same~$n$, we shall write $\<p,\alpha,m>\step{n}\<p',\alpha',m'>$
for~$\<p,\alpha,m,n>\step{}\<p',\alpha',m',n>$.

Relation~$\step{}$ is defined inductively with the help of
functions~$\eval$, $\blocked$, and~$\clear$.  The~$\eval$ function evaluates
arithmetic or boolean expressions on a given memory; we omit its definition
and assume that such evaluation is deterministic and always terminates.
The~$\blocked$ function is a predicate that determines if all trails of a
program~$p$ are blocked on a given event stack and reaction number.  And
the~$\clear$ function extracts the body of active~$\ceu{\Fin}$ blocks from a
given program.

\begin{definition}[label={def:sem:blocked}]
  Function~$\blocked\colon{P\times{E^*}\times{N}}\to\{0,1\}$ is defined
  inductively as follows.
  \begin{align*}
    \blocked(\ceu{\Skip},\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Attr{v}{a}},\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Break},\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Await(e)},\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Emit(e)},\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{\Ifelse{b}{p_1}{p_2}},\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{p_1;p_2},\alpha,n)
    &=\blocked(p_1,\alpha,n)\\
    %%
    \blocked(\ceu{\Loop p},\alpha,n)
    &=0\\
    %%
    \blocked(\ceu{p_1\And p_2},\alpha,n)
    &=\blocked(p_1,\alpha,n)\cdot\blocked(p_2,\alpha,n)\\
    %%
    \blocked(\ceu{p_1\Or p_2},\alpha,n)
    &=\blocked(p_1,\alpha,n)\cdot\blocked(p_2,\alpha,n)\\
    %%
    \blocked(\ceu{\Fin p_1},\alpha,n)
    &=1\\
    % %%
    \blocked(\ceu{\Awaiting(e',n')},e\alpha,n)
    &=
      \begin{cases}
        1 &\text{if~$e\ne{e'}$ or~$n'>n$}\\
        0 &\text{otherwise}
      \end{cases}\\
    %%
    \blocked(\ceu{\Emitting(n')},\alpha,n)
    &=
      \begin{cases}
        1 &\text{if~}\|\alpha|\ne{n'}\\
        0 &\text{otherwise}
      \end{cases}\\
    %%
    \blocked(\ceu{p_1\Atloop p_2},\alpha,n)
    &=\blocked(p_1,\alpha,n)
  \end{align*}
\end{definition}

\begin{definition}[label={def:sem:clear}]
  Function $\clear\colon{P}\to{P^\star}$ is defined inductively as follows.
  \begin{align*}
    \clear(\ceu\Skip)
    &=\ceu\Skip\\
    %%
    \clear(\ceu{\Attr{v}{a}})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Break})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Await(e')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Emit(e')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Ifelse{b}{p_1}{p_2}})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{p_1;p_2})
    &=\clear(p_1)\\
    %%
    \clear(\ceu{\Loop p})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{p_1\And p_2})
    &=\clear(p_1);\clear(p_2)\\
    %%
    \clear(\ceu{p_1\Or p_2})
    &=\clear(p_1);\clear(p_2)\\
    %%
    \clear(\ceu{\Fin p})
    &=p\\
    % %%
    \clear(\ceu{\Awaiting(e',n')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{\Emitting(n')})
    &=\ceu{\Skip}\\
    %%
    \clear(\ceu{p_1\Atloop p_2})
    &=\clear(p_1)
  \end{align*}
\end{definition}

\begin{definition}[label={def:sem:inner-step},name={Reaction inner-step}]
  Relation~$\step{\null}\subseteq\Delta\times\Delta$ is defined inductively
  as follows.

  \noindent\emph{Skip, attribution, and break}
  \begin{align}
    \label{def:sem:inner:skip}
    \<\ceu{\Skip},\alpha,m>
    &\step{n}\<\ceu{\Skip},\alpha,m>
    \\[1\jot]
    %%
    \label{def:sem:inner:attr}
    \<\ceu{\Attr{v}{a}},\alpha,m>
    &\step{n}\<\ceu\Skip,\alpha,m[v/\eval(a)]>
    \\[1\jot]
    %%
    \label{def:sem:inner:break}
    \<\ceu\Break,\alpha,m>
    &\step{n}\<\ceu\Skip,\alpha,m>
    %%
  \end{align}

  \noindent\emph{Await and emit}
  \begin{alignat}{2}
    \label{def:sem:inner:await}
    \<\ceu{\Await(e)},\alpha,m>
    &\step{n}\<\ceu{\Awaiting(e,n')},\alpha,m>
    &&\quad\text{with~$n'=n+1$}
    \\[1\jot]
    %%
    \label{def:sem:inner:awaiting}
    \<\ceu{\Awaiting(e,n')},e\alpha,m>
    &\step{n}\<\ceu{\Skip},e\alpha,m>
    &&\quad\text{if~$n'\le{n}$}
    \\[1\jot]
    %%
    \label{def:sem:inner:emit}
    \<\ceu{\Emit(e)},\alpha,m>
    &\step{n}\<\ceu{\Emitting(n')},e\alpha,m>
    &&\quad\text{with~$n'=\|\alpha|$}
    \\[1\jot]
    %%
    \label{def:sem:inner:emitting}
    \<\ceu{\Emitting(n')},\alpha,m>
    &\step{n}\<\ceu{\Skip},\alpha,m>
    &&\quad\text{if~$n'=\|\alpha|$}
  \end{alignat}

  \noindent\emph{Conditionals}
  \begin{alignat}{2}
    \label{def:sem:inner:if-true}
    \<\ceu{\Ifelse{b}{p_1}{p_2}},\alpha,m>
    &\step{n}\<p_1,\alpha,m>
    &&\quad\text{if~$\eval(b,m)=1$}
    \\[1\jot]
    %%
    \label{def:sem:inner:if-false}
    \<\ceu{\Ifelse{b}{p_1}{p_2}},\alpha,m>
    &\step{n}\<p_2,\alpha,m>
    &&\quad\text{if~$\eval(b,m)=0$}
  \end{alignat}

  \noindent\emph{Sequences}
  \begin{alignat}{2}
    \label{def:sem:inner:seq-skip}
    \<\ceu\Skip;p,\alpha,m>
    &\step{n}\<p,\alpha,m>
    &&
    \\[1\jot]
    %%
    \label{def:sem:inner:seq-break}
    \<\ceu{\Break;p},\alpha,m>
    &\step{n}\<\ceu{\Break},\alpha,m>
    &&
    \\[1\jot]
    %%
    \label{def:sem:inner:seq}
    &\hskip-5.3em
    \AXC{$\<p_1,\alpha,m>\step{n}\<p_1',\alpha',m'>$}
    \UIC{$\<p_1;p_2,\alpha,m>\step{n}\<p_1';p_2,\alpha',m'>$}
    \DP
    &&
  \end{alignat}

  \noindent\emph{Loops}
  \begin{alignat}{2}
    \label{def:sem:inner:loop}
    \<\ceu{\Loop p},\alpha,m>
    &\step{n}\<\ceu{p\Atloop{p}},\alpha,m>
    &&
    \\[1\jot]
    %%
    \label{def:sem:inner:atloop-skip}
    \<\ceu{\Skip\Atloop{p}},\alpha,m>
    &\step{n}\<\ceu{\Loop{p}},\alpha,m>
    &&
    \\[1\jot]
    %%
    \label{def:sem:inner:atloop-break}
    \<\ceu{\Break\Atloop{p}},\alpha,m>
    &\step{n}\<\ceu{\Skip},\alpha,m>
    &&
    \\[1\jot]
    %%
    \label{def:sem:inner:atloop}
    &\hskip-7.75em
    \AXC{$\<p_1,\alpha,m>\step{n}\<p_1',\alpha',m'>$}
    \UIC{$\<\ceu{p_1\Atloop{p_2}},\alpha,m>
      \step{n}\<\ceu{p_1'\Atloop{p_2}},\alpha',m'>$}
    \DP
    &&
  \end{alignat}

  \noindent\emph{Par/and}
  \begin{alignat}{2}
    \label{def:sem:inner:and-skip-left}
    \<\ceu{\Skip\And{\;p}},\alpha,m>
    &\step{n}\<p,\alpha,m>
    &&
    \\[1\jot]
    %%
    \label{def:sem:inner:and-skip-right}
    \<\ceu{p\And\Skip},\alpha,m>
    &\step{n}\<p,\alpha,m>
    &&\quad\text{\MARK{if~$\blocked(p,\alpha,n)=1$}}
    \\[1\jot]
    %%
    \label{def:sem:inner:and-break-left}
    \<\ceu{\Break\And\;p},\alpha,m>
    &\step{n}\<\ceu{p';\Break},\alpha,m>
    &&\quad\text{with~$p'=\clear(p)$}
    \\[1\jot]
    %%
    \label{def:sem:inner:and-break-right}
    \<\ceu{p\And\Break},\alpha,m>
    &\step{n}\<\ceu{p';\Break},\alpha,m>
    &&\quad\parbox{10em}{if~$\blocked(p,\alpha,n)=1$,\\
      \strut\enspace with~$p'=\clear(p)$}
    \\[1\jot]
    %%
    &\hskip-6.9em
    \label{def:sem:inner:and-left}
    \AXC{$\<p_1,\alpha,m>\step{n}\<p_1',\alpha',m'>$}
    \UIC{$\<\ceu{p_1\And{p_2}},\alpha,m>\step{n}
      \<\ceu{p_1'\And{p_2}},\alpha',m'>$}
    \DP
    &&\quad\text{if~$\blocked(p_1,\alpha,n)=0$}
    \\[1\jot]
    %%
    &\hskip-6.9em
    \label{def:sem:inner:and-right}
    \AXC{$\<p_2,\alpha,m>\step{n}\<p_2',\alpha',m'>$}
    \UIC{$\<\ceu{p_1\And{p_2}},\alpha,m>\step{n}
      \<\ceu{p_1\And{p_2'}},\alpha',m'>$}
    \DP
    &&\quad\text{if~$\blocked(p_1,\alpha,n)=1$}
  \end{alignat}

  \noindent\emph{Par/or}
  \begin{alignat}{2}
    \label{def:sem:inner:or-skip-left}
    \<\ceu{\Skip\Or{\;p}},\alpha,m>
    &\step{n}\<p',\alpha,m>
    &&\quad\text{\MARK{with~$p'=\clear(p)$}}
    \\[1\jot]
    %%
    \label{def:sem:inner:or-skip-right}
    \<\ceu{p\Or\Skip},\alpha,m>
    &\step{n}\<p',\alpha,m>
    &&\quad\parbox{10em}{\MARK{if~$\blocked(p,\alpha,n)=1$,\\
        \strut\enspace with~$p'=\clear(p)$}}
    \\[1\jot]
    %%
    \label{def:sem:inner:or-break-left}
    \<\ceu{\Break\Or\;p},\alpha,m>
    &\step{n}\<\ceu{p';\Break},\alpha,m>
    &&\quad\text{with~$p'=\clear(p)$}
    \\[1\jot]
    %%
    \label{def:sem:inner:or-break-right}
    \<\ceu{p\Or\Break},\alpha,m>
    &\step{n}\<\ceu{p';\Break},\alpha,m>
    &&\quad\parbox{10em}{if~$\blocked(p,\alpha,n)=1$,\\
      \strut\enspace with~$p'=\clear(p)$}
    \\[1\jot]
    %%
    &\hskip-6.4em
    \label{def:sem:inner:or-left}
    \AXC{$\<p_1,\alpha,m>\step{n}\<p_1',\alpha',m'>$}
    \UIC{$\<\ceu{p_1\Or{p_2}},\alpha,m>\step{n}
      \<\ceu{p_1'\Or{p_2}},\alpha',m'>$}
    \DP
    &&\quad\text{if~$\blocked(p_1,\alpha,n)=0$}
    \\[1\jot]
    %%
    &\hskip-6.4em
    \label{def:sem:inner:or-right}
    \AXC{$\<p_2,\alpha,m>\step{n}\<p_2',\alpha',m'>$}
    \UIC{$\<\ceu{p_1\Or{p_2}},\alpha,m>\step{n}
      \<\ceu{p_1\Or{p_2'}},\alpha',m'>$}
    \DP
    &&\quad\text{if~$\blocked(p_1,\alpha,n)=1$}
  \end{alignat}
\end{definition}

The next theorem establishes that the reaction inner-step relation is
deterministic, i.e., that it is in fact a \emph{partial} function.

\begin{restatable}[label={thm:sem:det-inner},
name={Determinism of the inner-step relation}]{theorem}{thmsemdetinner}
For all~$p$, $p_1$, $p_2\in{P}$, $\alpha$, $\alpha_1$, $\alpha_2\in{E^*}$,
$m$, $m_1$, $m_2\in\mathcal{M}$, and~$n\in{N}$,
\begin{gather*}
  \text{if}\quad\<p,\alpha,m>\step{n}\<p_1,\alpha_1,m_1>
  \quad\text{and}\quad
  \<p,\alpha,m>\step{n}\<p_2,\alpha_2,m_2>,\\
  \text{then}\quad\<p_1,\alpha_1,m_1>=\<p_2,\alpha_2,m_2>.
\end{gather*}
\end{restatable}
\begin{proof}
  By induction on the structure of derivations.
  See page~\pageref{proof:sem:det-inner}.
\end{proof}

The next lemma establishes that, given a program~$p$, either it is possible
to advance~$p$ by one inner-step or all trails of~$p$ are blocked, but not
both.

\begin{restatable}[label={lem:sem:inner-step-or-blocked}]{lemma}
  {lemseminnersteporblocked}
  For all~$p\in{P}$, $\alpha\in{E^*}$, $m\in\mathcal{M}$, and~$n\in{N}$,
  then either
  \[
    \exists{\delta\in\Delta}(\<p,\alpha,m>\step{n}\delta)
    \quad\text{or}\quad\blocked(p,\alpha,n)=1,
  \]
  but not both.
\end{restatable}
\begin{proof}
  By induction on the structure of programs.
  See page~\pageref{proof:sem:inner-step-or-blocked}.
\end{proof}

Configurations of the form~$\<p,\alpha,m,n>$, where~$p=\ceu\Skip$
or~$\blocked(p,\alpha,n)=1$, serve as normal forms for inner-steps, i.e.,
their state~$\<\alpha,m>$ embodies the result of an exhaustive number of
applications of inner-step.  This observation is formalized by the next
theorem.

\begin{restatable}[label={lem:sem:inner-step-outcome}]{theorem}
  {thmseminnerstepoutcome}
  Let~$\stepx{n}$ denote the reflexive-transitive closure of
  relation~$\step{n}$.  Then, for all~$p\in{P}$, $\alpha\in{E^*}$,
  $m\in\mathcal{M}$, and~$n\in{N}$,
  \[
    \exists{d\in\Delta}(\<p,\alpha,m>\stepx{n}\delta),
  \]
  where~$\delta=\<p',\alpha',m',n>$ and~$p'=\ceu{\Skip}$
  or~$\blocked(p',\alpha',n)=1$.
\end{restatable}
\begin{proof}
  \TODO{Induction on the structure of~$p$.}
\end{proof}


\subsection{The reaction outer-step relation}
\label{sub:sem:outer}

From the previous inner-step relation we define the outer-step
relation~($\ostep{}$) which when necessary pops the event stack and advances
blocked programs.  The auxiliary function~$\pop$ is used to pop the event
stack.

\begin{definition}[label={def:sem:pop}]
  Function~$\pop\colon{E^*}\to{E^*}$ is defined as follows.
  \begin{align*}
    \pop(\nil)&=\nil\\
    \pop(e\alpha)&=\alpha
  \end{align*}
\end{definition}

\begin{definition}[label={def:sem:outer-step},name={Reaction outer-step}]
  \begin{alignat}{2}
    \label{def:sem:outer:advance}
    &\hskip-3.45em
    \AXC{$\<p,\alpha,m>\step{n}\<p',\alpha',m'>$}
    \UIC{$\<p,\alpha,m>\ostep{n}\<p',\alpha',m'>$}
    \DP
    &&\quad\text{if~$\blocked(p,\alpha,n)=0$}
    \\[1\jot]
    %%
    \label{def:sem:outer:pop}
    \<p,e\alpha,m>
    &\ostep{n}\<p,\alpha',m>
    &&\quad\parbox{10em}{if~$\blocked(p,\alpha,n)=1$,\\
        \strut\enspace with~$\alpha'=\pop(\alpha)$}
  \end{alignat}
\end{definition}

The next two theorem establish that the outer-steps are deterministic and
always terminate for nontrivial programs, i.e., that it is in fact the
reaction outer-step relation is in fact a \emph{total} function (for
nontrivial programs).

\begin{theorem}[label={thm:sem:det-outer},
  name={Determinism of the outer-step relation}]
  For all~$p$, $p_1$, $p_2\in{P}$, $\alpha$, $\alpha_1$, $\alpha_2\in{E^*}$,
  $m$, $m_1$, $m_2\in\mathcal{M}$, and~$n\in{N}$,
  \begin{gather*}
    \text{if}\quad\<p,\alpha,m>\ostep{n}\<p_1,\alpha_1,m_1>
    \quad\text{and}\quad
    \<p,\alpha,m>\ostep{n}\<p_2,\alpha_2,m_2>,\\
    \text{then}\quad\<p_1,\alpha_1,m_1>=\<p_2,\alpha_2,m_2>.
  \end{gather*}
\end{theorem}
\input{revised-outer-det-proof2}

\begin{theorem}[label={thm:sem:term-outer},
  name={Termination of the outer-step relation}]
  For all~$p\in{P}$, $\alpha\in{E}$, and~$m\in\mathcal{M}$,
  if~$p\ne\ceu{\Break,\Fin,\Term}$, then
  \[
    \exists{\delta\in\Delta}(\<p,\alpha,m>\ostep{n}\delta).
  \]
\end{theorem}
\input{revised-outer-term-proof2}


\subsection{The reaction relation}
\label{sub:sem:reaction}

From the reflexive-transitive closure of the outer-step
relation~($\ostep{\ast}$) we define the reaction
relation~$\react{}\subseteq\Delta\times(P\times\mathcal{M}\times{N})$, which
computes a full program reaction.  Given an initial configuration, the
reaction relation evaluates it until the event stack becomes empty.

\begin{definition}[label={def:sem:reaction},name={Reaction}]
  Let~$p$, $p'\in{P}$, $\alpha\in{E^*}$, $m$, $m'\in\mathcal{M}$.  Then
  \[
    \<p,\alpha,m>\react{n}\<p',m'>
    \quad\text{iff}\quad
    \<p,\alpha,m,n>\ostep\ast\<p',\nil,m',n>.
  \]
\end{definition}

The next two theorems establish, respectively, that reactions are
deterministic and always terminate (for nontrivial programs).  The proofs of
these theorems depend on the assumption that every execution path within the
body of a loop instruction ($\ceu{\Loop{p}}$) contains an occurrence
of~$\ceu{\Break}$ or~$\ceu{\Await(e)}$.  This assumption is checked
statically by the \Ceu\ compiler.
%%
\todo{Na nova semântica basta dizer que~$e$ é um evento externo.}

\FIXME{Antes do determinismo e terminação precisa de um lema para grantir a
  correção da definição anterior, i.e., que um número finito de passos
  eventualmente leva a uma configuração com pilha vazia.  Nessa prova vai
  ser preciso usar a hipótese do loop.  A prova deve sair por indução no
  número de passos.}

\begin{theorem}[label={thm:sem:det-react},
  name={Determinism of the reaction relation}]
  For all~$p$, $p_1$, $p_2\in{P}$, $\alpha\in{E^*}$, $m$, $m_1$, $m_2\in\mathcal{M}$, and~$n\in{N}$,
  \begin{gather*}
    \text{if}\quad\<p,\alpha,m>\react{n}\<p_1,m_1>
    \quad\text{and}\quad
    \<p,\alpha,m>\react{n}\<p_2,m_2>,\\
    \text{then}\quad\<p_1,m_1>=\<p_2,m_2>.
  \end{gather*}
\end{theorem}
\begin{proof}
  \TODO{?}
\end{proof}

The~$\halted$ function is a predicate that determines if a program has finished
a reaction on a given event stack and reaction number.

\begin{definition}[label={def:sem:halted}]
  Function~$\halted\colon{P\times{E^*}\times{N}}\to\{0,1\}$ is defined
  inductively as follows.
  %%
  %%
  \begin{align*}
    \halted(p,\alpha,n)
    &=
      \begin{cases}
        \halted(p,\epsilon,n) &\text{if~$\alpha=\epsilon$}\\
        0 &\text{otherwise}
      \end{cases}\\
    %%
    \halted(\ceu\Term,\epsilon,n)
    &=1\\
    \halted(\ceu{\Skip},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{\Attr{v}{a}},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{\Await(e)},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{\Emit(e)},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{\Break},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{\Ifelse{b}{p_1}{p_2}},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{p_1;p_2},\epsilon,n)
    &=\halted(p_1,\epsilon,n)\\
    %%
    \halted(\ceu{\Loop p},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{p_1\And p_2},\epsilon,n)
    &=\halted(p_1,\epsilon,n)\cdot\halted(p_2,\epsilon,n)\\
    %%
    \halted(\ceu{p_1\Or p_2},\epsilon,n)
    &=\halted(p_1,\epsilon,n)\cdot\halted(p_2,\epsilon,n)\\
    %%
    \halted(\ceu{\Fin p_1},\epsilon,n)
    &=1\\
    % %%
    \halted(\ceu{\Awaiting(e',n')},\epsilon,n)
    &=
      \begin{cases}
        1 &\text{if~$n'>n$}\\
        0 &\text{otherwise}
      \end{cases}\\
    %%
    \halted(\ceu{\Emitting(n')},\epsilon,n)
    &=0\\
    %%
    \halted(\ceu{p_1\Atloop p_2},\epsilon,n)
    &=\halted(p_1,\epsilon,n)
  \end{align*}
\end{definition}

\begin{theorem}[label={thm:sem:term-react},
  name={Termination of the reaction relation}]
  For all~$p\in{P}$, $\alpha\in{E}$, and~$m\in\mathcal{M}$,
  if~$p\ne\ceu{\Skip},\ceu{\Attr{v}{a}},\ceu{\Break}$ then
  \[
    \<p,\alpha,m>\react{n}\<p',m'>,
  \]
  for some~$p'\in{P}$ and~$m'\in\mathcal{M}$.
\end{theorem}
\begin{proof}
  \TODO{?}
\end{proof}


\section{Detailed proofs}
\label{sec:proofs}

\thmsemdetinner*
\begin{proof}\label{proof:sem:det-inner}
  By induction on the structure of derivations.
  Suppose
  \[
    d_1\Vdash\<p,\alpha,m>\step{n}\<p_1,\alpha_1,m_1>
    \quad\text{and}\quad
    d_2\Vdash\<p,\alpha,m>\step{n}\<p_2,\alpha_2,m_2>,
  \]
  for some derivations~$d_1$ and~$d_2$.  Then the following cases are
  possible depending on the structure of~$p$.  (Note that the implication is
  trivially true for~$p=\ceu\Fin$ as there are no rules to evaluate such
  programs.)
  \begin{case}
  \item$p=\ceu{\Skip}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:skip}.  Thus~$p_1=p_2=\ceu{\Skip}$,
    $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
  \item$p=\ceu{\Attr{v}{a}}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:attr}.  Thus~$p_1=p_2=\ceu{\Skip}$,
    $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m[v/\eval(a)]$.
    %%
  \item$p=\ceu{\Break}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:break}.  Thus~$p_1=p_2=\ceu\Skip$,
    $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
    %%
  \item$p=\ceu{\Await(e)}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:await}.  Thus~$p_1=p_2=\ceu{\Awaiting(e,n')}$
    (with~$n'=n+1$), $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
    %%
  \item$p=\ceu{\Awaiting(e,n')}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:awaiting} with~$n'\le{n}$.
    Thus~$p_1=p_2=\ceu{\Skip}$, $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
    %%
  \item$p=\ceu{\Emit(e)}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:emit}.  Thus $p_1=p2=\ceu{\Emitting(n')}$
    (with~$n'=\|\alpha|$), $\alpha_1=\alpha_2=e\alpha$ and~$m_1=m_2=m$.
    %%
  \item$p=\ceu{\Emitting(e,n')}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:emitting} with~$n'=\|\alpha|$.
    Thus~$p_1=p_2=\ceu{\Skip}$, $\alpha_1=\alpha_2=\alpha$ and~$m_1=m_2=m$.
    %%
  \item$p=\ceu{\Ifelse{b}{p'}{p''}}$.
    \begin{case}
    \item$\eval(b,m)=1$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:if-true}.  Thus~$p_1=p_2=p'$,
      $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
      %%
    \item$\eval(b,m)=0$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:if-false}.  Thus~$p_1=p_2=p''$,
      $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
    \end{case}
    %%
  \item$p=\ceu{p';p''}$.
    \begin{case}
    \item$p'=\ceu\Skip$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:seq-skip}.  Thus $p_1=p_2=p''$,
      $\alpha_1=\alpha_2=\alpha$, and $m_1=m_2=m$.
      %%
    \item$p'=\ceu{\Break}$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:seq-break}.  Thus~$p_1=p_2=p'$,
      $\alpha_1=\alpha_2=\alpha$ and~$m_1=m_2=m$.
      %%
    \item$p'\ne\ceu{\Skip,\Break}$.  Then~$d_1$ and~$d_2$
      are instances of rule~\eqref{def:sem:inner:seq}.  Thus there are
      derivations~$d_1'$ and~$d_2'$ such that
      \begin{align*}
        d_1'\Vdash\<p',\alpha,m>\step{n}\<p_1',\alpha_1,m_1>
        \quad\text{and}\quad
        d_2'\Vdash\<p',\alpha,m>\step{n}\<p_2',\alpha_2,m_2>,
      \end{align*}
      for some~$p_1'$, $p_2'\in{P}$.  Since~$d_1'\prec{d_1}$
      and~$d_2'\prec{d_2}$, by induction hypothesis, $\alpha_1=\alpha_2$,
      $m_1=m_2$, and~$p_1'=p_2'$, which implies
      \[
        p_1=p_1';p''=p_2';p''=p_2.
      \]
    \end{case}
    %%
  \item$p=\ceu{\Loop{p'}}$.  Then~$d_1$ and~$d_2$ are instances of
    rule~\eqref{def:sem:inner:loop}.  Thus~$p_1=p_2=\ceu{p'\Atloop{p'}}$,
    $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
    %%
  \item$p=\ceu{p'\Atloop{p''}}$.
    \begin{case}
    \item$p'=\ceu\Skip$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:atloop-skip}.
      Thus~$p_1=p_2=\ceu{\Loop{p'}}$, $\alpha_1=\alpha_2=\alpha$,
      and~$m_1=m_2=m$.
      %%
    \item$p'=\ceu\Break$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:atloop-break}.  Thus~$p_1=p_2=\ceu{\Skip}$,
      $\alpha_1=\alpha_2=\alpha$, and~$m_1=m_2=m$.
      %%
    \item$p'\ne\ceu{\Skip,\Break}$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:atloop}.  Thus there are derivations~$d_1'$
      and~$d_2'$ such that
      \[
        d_1'\Vdash\<p',\alpha,m>\step{n}\<p_1',\alpha_1,m_1>
        \quad\text{and}\quad
        d_2'\Vdash\<p',\alpha,m>\step{n}\<p_2',\alpha_2,m_2>,
      \]
      for some~$p_1'$, $p_2'\in{P}$.  Since~$d_1'\prec{d_1}$
      and~$d_2'\prec{d_2}$, by induction hypothesis, $\alpha_1=\alpha$,
      $m_1=m_2$, and~$p_1'=p_2'$, which implies
      \[
        p_1=\ceu{p_1'\Atloop{p''}}=\ceu{p_2'\Atloop{p''}}=p_2.
      \]
    \end{case}
    %%
  \item\label{thm:sem:det-inner:and}$p=\ceu{p'\And{p''}}$.
    \begin{case}
    \item\label{thm:sem:det-inner:and-skip-left} $p'=\ceu\Skip$. Then~$d_1$
      and~$d_2$ are instances of rule~\eqref{def:sem:inner:and-skip-left}.
      Thus~$p_1=p_2=p''$, $\alpha_1=\alpha_2=\alpha$, and $m_1=m_2=m$.
      %%
    \item$p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu\Skip$.
      If~$\blocked(p',\alpha,m)=0$, this case
      becomes~\Cref{thm:sem:det-inner:and-left}.  Otherwise,
      if~$\blocked(p',\alpha,m)=1$, then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:and-skip-right}; thus~$p_1=p_2=p'$,
      $\alpha_1=\alpha_2=\alpha$, and $m_1=m_2=m$.
      %%
    \item $p'=\ceu\Break$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:and-break-left}.
      Thus~$\alpha_1=\alpha_2=\alpha$, $m_1=m_2=m$,
      and~$p_1=p_2=\ceu{\clear(p'');\Break}$.
      %%
    \item $p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu\Break$.
      If~$\blocked(p',\alpha,m)=0$, this case becomes
      \Cref{thm:sem:det-inner:and-left}.  Otherwise,
      if~$\blocked(p',\alpha,m)=1$, then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:and-break-right}; thus
      $\alpha_1=\alpha_2=\alpha$, $m_1=m_2=m$,
      and~$p_1=p_2=\ceu{\clear(p');\Break}$.
      %%
    \item\label{thm:sem:det-inner:and-left} $p',p''\ne\ceu\Skip,\ceu\Break$.
      If~$\blocked(p',\alpha,m)=0$, then~$d_1$~and~$d_2$ are instances
      of~\eqref{def:sem:inner:and-left}.  Thus there are derivations~$d_1'$
      and~$d_2'$ such that
      \[
        d_1'\Vdash\<p',\alpha,m>\step{n}\<p_1',\alpha_1,m_1>
        \quad\text{and}\quad
        d_2'\Vdash\<p',\alpha,m>\step{n}\<p_2',\alpha_2,m_2>,
      \]
      for some~$p_1'$, $p_2'\in{P}$.  Since~$d_1'\prec{d_1}$
      and~$d_2'\prec{d_2}$, by induction hypothesis, $\alpha_1=\alpha_2$,
      $m_1=m_2$, and~$p_1'=p_2'$, which implies
      \[
        p_1=(\ceu{p_1'\And{p''}})=(\ceu{p_2'\And{p''}})=p_2.
      \]

      If, however, $\blocked(p',\alpha,m)=1$, then~$d_1$~and~$d_2$ are
      instances of~~\eqref{def:sem:inner:and-right}.  Thus there are
      derivations~$d_1''$ and~$d_2''$ such that
      \[
        d_1''\Vdash\<p'',\alpha,m>\step{n}\<p_1'',\alpha_1,m_1>
        \quad\text{and}\quad
        d_2''\Vdash\<p'',\alpha,m>\step{n}\<p_2'',\alpha_2,m_2>,
      \]
      for some~$p_1''$, $p_2''\in{P}$.  Since~$d_1''\prec{d_1}$
      and~$d_2''\prec{d_2}$, by induction hypothesis, $\alpha_1=\alpha_2$,
      $m_1=m_2$, and~$p_1''=p_2''$, which implies
      \[
        p_1=(\ceu{p'\And{p_1''}})=(\ceu{p'\And{p_2''}})=p_2.
      \]
    \end{case}
    %%
  \item$p=\ceu{p'\Or{p''}}$.
    \begin{case}
    \item$p'=\ceu\Skip$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:or-skip-left}.
      Thus~$\alpha_1=\alpha_2=\alpha$, $m_1=m_2=m$,
      and~$p_1=p_2=\ceu\clear(p'')$.
      %%
    \item $p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu\Skip$.
      If~$\blocked(p',\alpha,m)=0$, this case becomes
      \Cref{thm:sem:det-inner:or-left}.  Otherwise,
      if~$\blocked(p',\alpha,m)=1$, then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:or-skip-right};
      thus~$\alpha_1=\alpha_2=\alpha$, $m_1=m_2=m$,
      and~$p_1=p_2=\ceu\clear(p')$.
      %%
    \item$p'=\ceu\Break$.  Then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:or-break-left}.
      Thus~$\alpha_1=\alpha_2=\alpha$, $m_1=m_2=m$,
      and~$p_1=p_2=\ceu{\clear(p'');\Break}$.
      %%
    \item $p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu\Break$.
      If~$\blocked(p',\alpha,m)=0$, this case becomes
      \Cref{thm:sem:det-inner:or-left}.  Otherwise,
      if~$\blocked(p',\alpha,m)=1$, then~$d_1$ and~$d_2$ are instances of
      rule~\eqref{def:sem:inner:or-break-right};
      thus~$\alpha_1=\alpha_2=\alpha$, $m_1=m_2=m$,
      and~$p_1=p_2=\ceu{\clear(p');\Break}$.
      %%
    \item\label{thm:sem:det-inner:or-left} $p',p''\ne\ceu{\Skip,\Break}$.
      If~$\blocked(p',\alpha,m)=0$, $d_1$~and~$d_2$ are instances
      of~\eqref{def:sem:inner:or-left}.  Thus there are derivations~$d_1'$
      and~$d_2'$ such that
      \[
        d_1'\Vdash\<p',\alpha,m>\step{n}\<p_1',\alpha_1,m_1>
        \quad\text{and}\quad
        d_2'\Vdash\<p',\alpha,m>\step{n}\<p_2',\alpha_2,m_2>,
      \]
      for some~$p_1'$, $p_2'\in{P}$.  Since~$d_1'\prec{d_1}$
      and~$d_2'\prec{d_2}$, by induction hypothesis, $\alpha_1=\alpha_2$,
      $m_1=m_2$, and~$p_1'=p_2'$, which implies
      \[
        p_1=(\ceu{p_1'\Or{p''}})=(\ceu{p_2'\Or{p''}})=p_2.
      \]

      If, however, $\blocked(p',\alpha,m)=1$, then~$d_1$ and~$d_2$ are
      instances of~~\eqref{def:sem:inner:or-right}.  Thus there are
      derivations~$d_1''$ and~$d_2''$ such that
      \[
        d_1''\Vdash\<p'',\alpha,m>\step{n}\<p_1'',\alpha_1,m_1>
        \quad\text{and}\quad
        d_2''\Vdash\<p'',\alpha,m>\step{n}\<p_2'',\alpha_2,m_2>,
      \]
      for some~$p_1''$, $p_2''\in{P}$.  Since~$d_1''\prec{d_1}$
      and~$d_2''\prec{d_2}$, by induction hypothesis, $\alpha_1=\alpha_2$,
      $m_1=m_2$, and~$p_1''=p_2''$, which implies
      \[
        p_1=(\ceu{p'\Or{p_1''}})=(\ceu{p'\Or{p_2''}})=p_2.\qedhere
      \]
    \end{case}
  \end{case}
\end{proof}

\lemseminnersteporblocked*
\begin{proof}\label{proof:sem:inner-step-or-blocked}
  By induction on the structure of programs.
  \begin{case}
  \item$p=\ceu\Skip$.  Then by rule~\eqref{def:sem:inner:skip}
    and~\Cref{def:sem:blocked},
    \[
      \delta=\<\ceu{\Skip},\alpha,m>
      \quad\text{and}\quad
      \blocked(\ceu{\Skip},\alpha,n)=0.
    \]
    %%
  \item$p=\ceu{\Attr{v}{a}}$.  Then by rule~\eqref{def:sem:inner:attr}
    and~\Cref{def:sem:blocked},
    \[
      \delta=\<\ceu\Skip,\alpha,m[v/\eval(a)]>
      \quad\text{and}\quad
      \blocked(\ceu{\Attr{v}{a}},\alpha,n)=0.
    \]
    %%
  \item$p=\ceu{\Break}$.  Then by rule~\eqref{def:sem:inner:break}
    and~\Cref{def:sem:blocked},
    \[
      \delta=\<\ceu\Skip,\alpha,m>
      \quad\text{and}\quad
      \blocked(\ceu{\Break},\alpha,n)=0.
    \]
    %%
  \item $p=\ceu{\Await(e)}$.  Then by rule~\eqref{def:sem:inner:await},
    $\delta=\<\ceu{\Awaiting(e,n')},\alpha,m>$, where $n'=n+1$.  And
    by~\Cref{def:sem:blocked}, $\blocked(\ceu{\Await(e)},\alpha,n)=0$.
    %%
  \item $p=\ceu{\Awaiting(e,n')}$.
    \begin{case}
    \item$n'\leq n$.  If~$e$ is the top-of-stack event in~$\alpha$, then by
      rule~\eqref{def:sem:inner:awaiting} and~\Cref{def:sem:blocked},
      \[
        \delta=\<\ceu{\Skip},\alpha,m>
        \quad\text{and}\quad
        \blocked(\ceu{\Awaiting(e,n')},\alpha,n)=0.
      \]
      If, however, $e$~is not on top of stack~$\alpha$ then there is no
      such~$\delta$, as no rule is applicable, and by
      \Cref{def:sem:blocked}, $\blocked(\ceu{\Awaiting(e,n')},\alpha,n)=1.$
    \item$n'>n$. Then there is no such~$\delta$ (no rule is applicable), and
      by~\Cref{def:sem:blocked},
      $\blocked(\ceu{\Awaiting(e,n')},\alpha,n)=1$.
    \end{case}
    %%
  \item$p=\ceu{\Emit(e)}$.  Then by rule~\eqref{def:sem:inner:emit},
    $\delta=\<\ceu{\Emitting(n')},e\alpha,m>$, where~$n'=\|\alpha|$, and
    by~\Cref{def:sem:blocked}, $\blocked(\ceu{\Emit(e')},e\alpha,n)=0$.
    %%
  \item $p=\ceu{\Emitting(e,n')}$.
    \begin{case}
    \item~$n'=\|\alpha|$.  By rule~\eqref{def:sem:inner:emitting}
      and~\Cref{def:sem:blocked},
      \[
        \delta=\<\ceu{\Skip},\alpha,m>
        \quad\text{and}\quad
        \blocked(\ceu{\Emitting(e,n')},\alpha,n)=0.
      \]
      %%
    \item~$n'\ne\|\alpha|$.  Then there is no such~$\delta$ (no rule is
      applicable) and, by \Cref{def:sem:blocked},
      $\blocked(\ceu{\Emitting(e,n')},\alpha,n)=1$.
    \end{case}
    %%
  \item$p=\ceu{\Fin}$.  Then there is no such~$\delta$ (no rule applicable),
    and by~\Cref{def:sem:blocked}, $\blocked(\ceu{\Fin{p}},\alpha,n)=1$.
    %%
  \item $p=\ceu{\Ifelse{b}{p'}{p''}}$.  By
    rules~\eqref{def:sem:inner:if-true} and~\eqref{def:sem:inner:if-false},
    if~$\eval(b,m)=1$, $\delta=\<p',\alpha,m>$,
    otherwise~$\delta=\<p'',\alpha,m>$.  And by~\Cref{def:sem:blocked},
    \[
      \blocked(\ceu{\Ifelse{b}{p'}{p''}},e\alpha,n)=0.
    \]
    %%
  \item$p=\ceu{p';p''}$.
    \begin{case}
    \item$p'=\ceu{\Skip}$.  By rule~\eqref{def:sem:inner:seq-skip},
      $\delta=\<p'',\alpha,m>$, and by~\Cref{def:sem:blocked},
      \[
        \blocked(\ceu{\Skip};p'', \alpha,n)
        =\blocked(\ceu{\Skip},\alpha,n)=0.
      \]
    \item$p'=\ceu\Break$.  By rule~\eqref{def:sem:inner:seq-break},
      $\delta=\<\ceu\Break,\alpha,m>$, and by~\Cref{def:sem:blocked},
      \[
        \blocked(\ceu{\Break};p'',\alpha,n)
        =\blocked(\ceu{\Break},\alpha,n)=0.
      \]
    \item$p'\ne\ceu{\Skip},\ceu{\Break}$.  By induction
      hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\<p',\alpha,m>\step{n}\<p_1',\alpha',m'>$, for some~$p_1'\in{P}$,
      $\alpha'\in{E^*}$, and~$m'\in\mathcal{M}$, then by
      rule~\eqref{def:sem:inner:seq},
      \[
        \<p';p'',\alpha,m>\step{n}\<p'_1;p'',\alpha',m'>,
      \]
      and by \Cref{def:sem:blocked},
      \[
        \blocked(p';p'',\alpha,n)=\blocked(p',\alpha,n)=0.
      \]

      If, however, $\blocked(p',\alpha,n)=1$, then there is no such~$d$ (no
      rule is applicable) and by \Cref{def:sem:blocked},
      \[
        \blocked(p';p'',\alpha,n)=\blocked(p',\alpha,n)=1.
      \]
    \end{case}
    %%
  \item$p=\ceu{\Loop{p'}}$.  By rule~\eqref{def:sem:inner:loop}
    and~\Cref{def:sem:blocked},
    \[
      \delta=\<\ceu{p'\Atloop{p'}},\alpha,m>
      \quad\text{and}\quad
      \blocked(\ceu{\Loop{p'}},\alpha,m)=0.
    \]
    %%
  \item$p=\ceu{p'\Atloop{p''}}$.
    \begin{case}
    \item$p'=\ceu{\Skip}$.  By rule~\eqref{def:sem:inner:atloop-skip},
      $\delta=\<\ceu{\Loop{p''}},\alpha,m>$, and by~\Cref{def:sem:blocked},
      \[
        \blocked(\ceu{\Skip\Atloop{p''}},\alpha,n)
        =\blocked(\ceu{\Skip},\alpha,n)=0.
      \]
    \item$p'=\ceu{\Break}$.  By rule~\eqref{def:sem:inner:atloop-break},
      $\delta=\<\ceu{\Skip},\alpha,m>$, and by~\Cref{def:sem:blocked},
      \[
        \blocked(\ceu{\Break\Atloop{p''}},\alpha,n)
        =\blocked(\ceu{\Break},\alpha,n)=0.
      \]
    \item$p'\ne\ceu{\Skip},\ceu{\Break}$.  By induction
      hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\<p',\alpha,m>\step{n}\<p_1',\alpha',m'>$, for some~$p_1'\in{P}$,
      $\alpha'\in{E^*}$, and~$m'\in\mathcal{M}$, then by
      rule~\eqref{def:sem:inner:atloop},
      \[
        \<\ceu{p'\Atloop{p''}},\alpha,m>
        \step{n}\<\ceu{p'_1\Atloop{p''}},\alpha',m'>,
      \]
      and by \Cref{def:sem:blocked},
      \[
        \blocked(\ceu{p'\Atloop{p''}},\alpha,n)=\blocked(p',\alpha,n)=0.
      \]

      If, however,~$\blocked(p',\alpha,n)=1$, then there is no such~$d$ (no
      rule is applicable) and by \Cref{def:sem:blocked},
      \[
        \blocked(\ceu{p'\Atloop{p''}},\alpha,n)=\blocked(p',\alpha,n)=1.
      \]
    \end{case}
    %%
  \item$p=\ceu{p'\And{p''}}$.
    \begin{case}
    \item$p'=\ceu{\Skip}$.  By rule~\eqref{def:sem:inner:and-skip-left},
      $\delta=\<\ceu{p''},\alpha,m>$, and by~\Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{\Skip\And\;p''},\alpha,n)
        &=\blocked(\ceu{\Skip},\alpha,n)
          \cdot\blocked(p'',\alpha,n)\\
        &=0.
      \end{align*}
    \item $p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu{\Skip}$.  By
      induction hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\blocked(p',\alpha,n)=0$, this case
      becomes~\Cref{thm:sem:lemma:and}.

      If, however,~$\blocked(p',\alpha,n)=1$, then by
      rule~\eqref{def:sem:inner:and-skip-right},
      $\delta=\<\ceu{p'},\alpha,m>$, and by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\And\;\Skip},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(\ceu\Skip,\alpha,n)\\
        &=1\cdot0=0.
      \end{align*}
    \item$p'=\ceu{\Break}$.  By rule~\eqref{def:sem:inner:and-break-left},
      $\delta=\<\ceu{\clear(p'')},\alpha,m>$, and
      by~\Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{\Break\And\;p''})
        &=\blocked(\ceu{\Break},\alpha,n)\cdot\blocked(p'',\alpha,n)\\
        &=0.
      \end{align*}
    \item $p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu\Break$.  By
      induction hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\blocked(p',\alpha,n)=0$, this case becomes
      \Cref{thm:sem:lemma:and}.

      If, however,~$\blocked(p',\alpha,n)=1$, then by
      rule~\eqref{def:sem:inner:and-break-right},
      $\delta=\<\clear(p'),\alpha,m>$, and by~\Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\And\;\Break})
        &=\blocked(p')\cdot\blocked(\ceu{\Break},\alpha,n)\\
        &=1\cdot0=0.
      \end{align*}

    \item\label{thm:sem:lemma:and} $p',p''\ne\ceu{\Skip},\ceu{\Break}$.  By
      induction hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\<p',\alpha,m>\step{n}\<p_1',\alpha',m'>$, for some~$p_1'\in{P}$,
      $\alpha'\in{E^*}$, and~$m'\in\mathcal{M}$, then by
      rule~\eqref{def:sem:inner:and-left},
      \[
        \<\ceu{p'\And{p''}},\alpha,m>
        \step{n}\<\ceu{p'_1\And{p''}},\alpha',m'>.
      \]
      And by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\And{p''}},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(p'',\alpha,n)\\
        &=0\cdot\blocked(p'',\alpha,n)=0.
      \end{align*}

      If, however,~$\blocked(p',\alpha,n)=1$ then, again, by induction
      hypothesis,
      \[
        \exists{d''\in\Delta}(\<p'',\alpha,m>\step{n}d'')
        \quad\text{or}\quad
        \blocked(p'',\alpha,n)=1,
      \]
      but not both.  Suppose~$\<p'',\alpha,m>\step{n}\<p_2'',\alpha',m'>$,
      for some~$p_2''\in{P}$, $\alpha'\in{E^*}$, and~$m'\in\mathcal{M}$.
      Then by rule~\eqref{def:sem:inner:and-right},
      \[
        \<\ceu{p'\And{p''}},\alpha,m>
        \step{n}\<\ceu{p'\And{p_2''}},\alpha',m'>,
      \]
      and by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\And{p''}},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(p'',\alpha,n)\\
        &=1\cdot0=0.
      \end{align*}
      Suppose~$\blocked(p'',\alpha,n)=1$.  Then there is no such~$\delta$
      (no rule is applicable) and by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\And{p''}},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(p'',\alpha,n)\\
        &=1\cdot1=1.
      \end{align*}
    \end{case}
    %%
  \item$p=\ceu{p'\Or{p''}}$.
    \begin{case}
    \item$p'=\ceu{\Skip}$.  By rule~\eqref{def:sem:inner:or-skip-left},
      $\delta=\<\ceu{\clear(p'')},\alpha,m>$, and by~\Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{\Skip\Or\;p''},\alpha,n)
        &=\blocked(\ceu{\Skip},\alpha,n)
          \cdot\blocked(p'',\alpha,n)\\
        &=0.
      \end{align*}
    \item$p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu{\Skip}$.  By induction
      hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\blocked(p',\alpha,n)=0$, this case
      becomes~\Cref{thm:sem:lemma:or}.

      If, however,~$\blocked(p',\alpha,n)=1$, then by
      rule~\eqref{def:sem:inner:or-skip-right},
      $\delta=\<\ceu{\clear(p')},\alpha,m>$, and by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\Or\;\Skip},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(\ceu\Skip,\alpha,n)\\
        &=1\cdot0=0.
      \end{align*}
    \item$p'=\ceu{\Break}$.  By rule~\eqref{def:sem:inner:or-break-left},
      $\delta=\<\ceu{\clear(p'');\Break},\alpha,m>$, and
      by~\Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{\Break\Or\;p''})
        &=\blocked(\ceu{\Break})\cdot\blocked(p'',\alpha,n)\\
        &=0.
      \end{align*}
    \item$p'\ne\ceu{\Skip,\Break}$ and~$p''=\ceu\Break$.  By induction
      hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\blocked(p',\alpha,n)=0$, this case becomes
      \Cref{thm:sem:lemma:or}.

      If, however,~$\blocked(p',\alpha,n)=1$, then by
      rule~\eqref{def:sem:inner:or-break-right},
      $\delta=\<\ceu{\clear(p');\Break},\alpha,m>$, and
      by~\Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\Or\;\Break})
        &=\blocked(p')\cdot\blocked(\ceu{\Break},\alpha,n)\\
        &=1\cdot0=0.
      \end{align*}
    \item\label{thm:sem:lemma:or}
      $p',p''\ne\ceu{\Skip},\ceu{\Break}$.  By induction
      hypothesis, exactly one of the following hold:
      \[
        \exists{d'\in\Delta}(\<p',\alpha,m>\step{n}d')
        \quad\text{or}\quad
        \blocked(p',\alpha,n)=1.
      \]

      If~$\<p',\alpha,m>\step{n}\<p_1',\alpha',m'>$, for some~$p_1'\in{P}$,
      $\alpha'\in{E^*}$, and~$m'\in\mathcal{M}$, then by
      rule~\eqref{def:sem:inner:or-left},
      \[
        \<\ceu{p'\Or{p''}},\alpha,m>
        \step{n}\<\ceu{p'_1\Or{p''}},\alpha',m'>.
      \]
      And by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\Or{p''}},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(p'',\alpha,n)\\
        &=0\cdot\blocked(p'',\alpha,n)=0.
      \end{align*}

      If, however,~$\blocked(p',\alpha,n)=1$ then, again, by induction
      hypothesis,
      \[
        \exists{d''\in\Delta}(\<p'',\alpha,m>\step{n}d'')
        \quad\text{or}\quad
        \blocked(p'',\alpha,n)=1,
      \]
      but not both.  Suppose~$\<p'',\alpha,m>\step{n}\<p_2'',\alpha',m'>$,
      for some~$p_2''\in{P}$, $\alpha'\in{E^*}$, and~$m'\in\mathcal{M}$.
      Then by rule~\eqref{def:sem:inner:or-right},
      \[
        \<\ceu{p'\Or{p''}},\alpha,m>
        \step{n}\<\ceu{p'\Or{p_2''}},\alpha',m'>,
      \]
      and by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\Or{p''}},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(p'',\alpha,n)\\
        &=1\cdot0=0.
      \end{align*}
      Suppose~$\blocked(p'',\alpha,n)=1$.  Then there is no such~$\delta$
      (no rule is applicable) and by \Cref{def:sem:blocked},
      \begin{align*}
        \blocked(\ceu{p'\Or{p''}},\alpha,n)
        &=\blocked(p',\alpha,n)\cdot\blocked(p'',\alpha,n)\\
        &=1\cdot1=1.\qedhere
      \end{align*}
    \end{case}
  \end{case}
\end{proof}

\thmseminnerstepoutcome*
\begin{proof}
\end{proof}

\end{document}
